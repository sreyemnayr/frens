{"standard_json_input": {"language": "Solidity", "sources": {"FrensMetadata.sol": {"content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport \"Base64.sol\";\nimport \"Utilities.sol\";\nimport \"FrensTraits.sol\";\nimport \"IFrens.sol\";\n\n/**\n\n@title  FrensMetadata\n@author VisualizeValue\n@notice Renders ERC721 compatible metadata for Frens.\n*/\nlibrary FrensMetadata {\n\n\n    /// @dev Get the Fren information given randomness + tokenId\n    /// @param tokenId The id of the token to render.\n    /// @param randomness The randomness generated by the epoch commit/reveal.\n    function tokenURI(\n      uint256 tokenId, uint128 randomness, string calldata baseURI\n    ) public pure returns (string memory) {\n      IFrens.Fren memory fren;\n      uint128 rando = 0;\n\n      if (randomness > 0) {\n        fren.isRevealed = true;\n        rando = uint128(uint256(keccak256(\n                abi.encodePacked(\n                    randomness,\n                    tokenId\n                ))) % (2 ** 128 - 1)\n        );\n\n        fren.palette = FrensTraits.palette(rando);\n        fren.colors = FrensTraits.colors(rando);\n        fren.rotation = FrensTraits.rotation(rando);\n        fren.direction = FrensTraits.direction(rando);\n        fren.segment = FrensTraits.segment(rando);\n        fren.inverted = rando % 1000 == 0;\n        fren.attention = rando % 2000 == 0;\n      }\n      \n\n      bytes memory metadata = abi.encodePacked(\n            '{',\n                '\"name\": \"Frens #', Utilities.uint2str(tokenId), '\",',\n                '\"description\": \"These frens may or may not be notable.\",',\n                '\"image\": \"',\n                    baseURI,\n                    Utilities.uint2str(rando),\n                    '.png',\n                    '\",',\n                '\"attributes\": [', attributes(fren), ']',\n            '}'\n        );\n      \n      return string(\n            abi.encodePacked(\n                \"data:application/json;base64,\",\n                Base64.encode(metadata)\n            )\n        );\n      \n    }\n\n\n\n    /// @dev Render the JSON atributes for a given Frens token.\n    /// @param fren The fren to render.\n    function attributes(IFrens.Fren memory fren) public pure returns (bytes memory) {\n\n        return abi.encodePacked(\n            fren.isRevealed\n                ? trait('Color Palette', string(abi.encodePacked('#',Utilities.uint2str(fren.palette))), ',')\n                : trait('Revealed', 'No', ','),\n            fren.isRevealed\n                ? trait('# Colors', string(abi.encodePacked(Utilities.uint2str(fren.colors), ' COLORS')), ',')\n                : '',\n            fren.isRevealed\n                ? trait('Palette Segment', fren.segment, ',')\n                : '',\n            fren.isRevealed\n                ? trait('Palette Rotation', string(abi.encodePacked(Utilities.uint2str(fren.rotation), 'x')), ',')\n                : '',\n            fren.isRevealed\n                ? trait('Palette Direction', fren.direction, ',')\n                : '',\n            fren.inverted\n                ? trait('Inverted', 'Yes', ',')\n                : '',\n            fren.attention\n                ? trait('Benefits', 'Yes', ',')\n                : '',\n            trait('Artist', 'Gabe Weis', '')\n        );\n    }\n\n    \n\n    /// @dev Generate the JSON for a single attribute.\n    /// @param traitType The `trait_type` for this trait.\n    /// @param traitValue The `value` for this trait.\n    /// @param append Helper to append a comma.\n    function trait(\n        string memory traitType, string memory traitValue, string memory append\n    ) public pure returns (string memory) {\n        return string(abi.encodePacked(\n            '{',\n                '\"trait_type\": \"', traitType, '\",'\n                '\"value\": \"', traitValue, '\"'\n            '}',\n            append\n        ));\n    }\n\n    \n\n}\n"}, "Base64.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Base64.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides a set of functions to operate with Base64 strings.\n *\n * _Available since v4.5._\n */\nlibrary Base64 {\n    /**\n     * @dev Base64 Encoding/Decoding Table\n     */\n    string internal constant _TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n    /**\n     * @dev Converts a `bytes` to its Bytes64 `string` representation.\n     */\n    function encode(bytes memory data) internal pure returns (string memory) {\n        /**\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\n         */\n        if (data.length == 0) return \"\";\n\n        // Loads the table into memory\n        string memory table = _TABLE;\n\n        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\n        // and split into 4 numbers of 6 bits.\n        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\n        // - `data.length + 2`  -> Round up\n        // - `/ 3`              -> Number of 3-bytes chunks\n        // - `4 *`              -> 4 characters for each chunk\n        string memory result = new string(4 * ((data.length + 2) / 3));\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Prepare the lookup table (skip the first \"length\" byte)\n            let tablePtr := add(table, 1)\n\n            // Prepare result pointer, jump over length\n            let resultPtr := add(result, 32)\n\n            // Run over the input, 3 bytes at a time\n            for {\n                let dataPtr := data\n                let endPtr := add(data, mload(data))\n            } lt(dataPtr, endPtr) {\n\n            } {\n                // Advance 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // To write each character, shift the 3 bytes (18 bits) chunk\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\n                // and apply logical AND with 0x3F which is the number of\n                // the previous character in the ASCII table prior to the Base64 Table\n                // The result is then added to the table to get the character to write,\n                // and finally write it in the result pointer but with a left shift\n                // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n            }\n\n            // When data `bytes` is not exactly 3 bytes long\n            // it is padded with `=` characters at the end\n            switch mod(mload(data), 3)\n            case 1 {\n                mstore8(sub(resultPtr, 1), 0x3d)\n                mstore8(sub(resultPtr, 2), 0x3d)\n            }\n            case 2 {\n                mstore8(sub(resultPtr, 1), 0x3d)\n            }\n        }\n\n        return result;\n    }\n}\n"}, "Utilities.sol": {"content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nlibrary Utilities {\n\n    /// @dev unpack one of 32 bit-packed uint8s from a uint256 (zero-indexed position)\n    function unpack(uint256 input, uint8 position) internal pure returns (uint8) {\n      return uint8(input >> (8*(position+1)));\n    }\n\n    /// @dev unpack a uint8s from a uint256 (zero-indexed offset)\n    function unpack_arbitrary(uint256 input, uint8 offset) internal pure returns (uint8) {\n      return uint8(input >> offset);\n    }\n\n    /// @dev Zero-index based pseudorandom number based on one input and max bound\n    function random(uint256 input, uint256 _max) internal pure returns (uint256) {\n        return (uint256(keccak256(abi.encodePacked(input))) % _max);\n    }\n\n    /// @dev Zero-index based salted pseudorandom number based on two inputs and max bound\n    function random(uint256 input, string memory salt, uint256 _max) internal pure returns (uint256) {\n        return (uint256(keccak256(abi.encodePacked(input, salt))) % _max);\n    }\n\n    /// @dev Convert an integer to a string\n    function uint2str(uint256 _i) internal pure returns (string memory _uintAsString) {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint256 j = _i;\n        uint256 len;\n        while (j != 0) {\n            ++len;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint256 k = len;\n        while (_i != 0) {\n            k = k - 1;\n            uint8 temp = (48 + uint8(_i - (_i / 10) * 10));\n            bytes1 b1 = bytes1(temp);\n            bstr[k] = b1;\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n\n    /// @dev Get the smallest non zero number\n    function minGt0(uint8 one, uint8 two) internal pure returns (uint8) {\n        return one > two\n            ? two > 0\n                ? two\n                : one\n            : one;\n    }\n\n    /// @dev Get the smaller number\n    function min(uint8 one, uint8 two) internal pure returns (uint8) {\n        return one < two ? one : two;\n    }\n\n    /// @dev Get the larger number\n    function max(uint8 one, uint8 two) internal pure returns (uint8) {\n        return one > two ? one : two;\n    }\n\n    /// @dev Get the average between two numbers\n    function avg(uint8 one, uint8 two) internal pure returns (uint8 result) {\n        unchecked {\n            result = (one >> 1) + (two >> 1) + (one & two & 1);\n        }\n    }\n\n    /// @dev Get the days since another date (input is seconds)\n    function day(uint256 from, uint256 to) internal pure returns (uint24) {\n        return uint24((to - from) / 24 hours + 1);\n    }\n}\n"}, "FrensTraits.sol": {"content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport \"Utilities.sol\";\n\n/**\n\n@title  FrensMetadata\n@author VisualizeValue\n@notice Renders ERC721 compatible metadata for Frens.\n*/\nlibrary FrensTraits {\n\n    function colors(\n      uint128 rando\n    ) public pure returns (uint8){\n      uint8 unpacked = Utilities.unpack(rando, 0);\n      if (unpacked > 254) return 64;\n      if (unpacked > 192) return 4;\n      if (unpacked > 128) return 3;\n      if (unpacked > 64) return 7;\n      if (unpacked > 32) return 6;\n      if (unpacked > 16) return 2;\n      if (unpacked > 8) return 16;\n      if (unpacked > 4) return 8;\n      if (unpacked > 2) return 32;\n      if (unpacked > 1) return 1;\n      return 0;\n    }\n\n    function palette(\n      uint128 rando\n    ) public pure returns (uint8){\n      return Utilities.unpack(rando, 1);\n    }\n\n    function rotation(\n      uint128 rando\n    ) public pure returns (uint8) {\n      uint8 unpacked = Utilities.unpack(rando, 2);\n      return unpacked % 8;\n    }\n\n    function direction(\n      uint128 rando\n    ) public pure returns (string memory) {\n      uint8 unpacked = Utilities.unpack(rando, 3);\n      return unpacked % 2 == 0 ? \"FORWARD\" : \"REVERSE\";\n    }\n\n    function segment(\n      uint128 rando\n    ) public pure returns (string memory){\n      uint8 unpacked = Utilities.unpack(rando, 4);\n      if (unpacked > 64) return \"FULL\";\n      if (unpacked > 42) return \"H2\";\n      if (unpacked > 20) return \"H1\";\n      if (unpacked > 16) return \"T3\";\n      if (unpacked > 12) return \"T2\";\n      if (unpacked > 8) return \"T1\";\n      if (unpacked > 6) return \"Q4\";\n      if (unpacked > 4) return \"Q3\";\n      if (unpacked > 2) return \"Q2\";\n      return \"Q1\";\n    }\n\n}"}, "IFrens.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n// Many thanks to the dev of the fantastic Checks smart contract \n\ninterface IFrens {\n\n    struct Fren {\n        uint8 palette;   // The palette ID (0-255)\n        uint8 colors;    // The number of colors ()\n        uint8 rotation;  // Number of steps the palette should be rotated\n        string direction; // Forward or backward\n        string segment;   // Full, H1, H2, Q1, Q2, Q3, Q4, T1, T2, T3\n        bool inverted;    // Yes/No\n        bool attention;     // Yes/No\n        uint32 epoch;      // Each fren is revealed in an epoch\n        bool isRevealed;      // Whether the fren is revealed\n        uint256 seed;        // The instantiated seed for pseudo-randomisation\n    }\n\n    struct Epoch {\n        uint128 randomness;    // The source of randomness for tokens from this epoch\n        uint64 revealBlock;   // The block at which this epoch was / is revealed\n        bool committed;      // Whether the epoch has been instantiated\n        bool revealed;      // Whether the epoch has been revealed\n    }\n\n    event NewEpoch(\n        uint256 indexed epoch,\n        uint64 indexed revealBlock\n    );\n\n    error NotAllowed();\n    error InvalidTokenCount();\n    error ZeroFren__InvalidFren();\n\n}\n"}}, "settings": {"evmVersion": "istanbul", "optimizer": {"enabled": true, "runs": 200}, "libraries": {"FrensMetadata.sol": {"FrensTraits": "0xe210418f634d5fCFDF6246b96e6dE6c5B59260e8"}}}}, "contract_name": "FrensMetadata", "compiler_version": "0.8.17+commit.8df45f5f", "optimizer_enabled": true, "optimizer_runs": 200, "license_identifier": "NONE", "bytecode_len": 10660, "libraries": {"FrensTraits.sol": {"FrensTraits": "0xe210418f634d5fCFDF6246b96e6dE6c5B59260e8"}}}